{"ast":null,"code":"'use strict';\n/**\n * This module manages MySQL connections in serverless applications.\n * More detail regarding the MySQL module can be found here:\n * https://github.com/mysqljs/mysql\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @version 1.5.3\n * @license MIT\n */\n\nmodule.exports = params => {\n  // Mutable values\n  let client = null; // Init null client object\n\n  let counter = 0; // Total reuses counter\n\n  let errors = 0; // Error count\n\n  let retries = 0; // Retry count\n\n  let _cfg = {}; // MySQL config globals\n\n  let _maxConns = {\n    updated: 0\n  }; // Cache max connections\n\n  let _usedConns = {\n    updated: 0\n  }; // Cache used connections\n  // Common Too Many Connections Errors\n\n  const tooManyConnsErrors = ['ER_TOO_MANY_USER_CONNECTIONS', 'ER_CON_COUNT_ERROR', 'ER_USER_LIMIT_REACHED', 'ER_OUT_OF_RESOURCES', 'ER_CON_COUNT_ERROR', 'PROTOCOL_CONNECTION_LOST', // if the connection is lost\n  'PROTOCOL_SEQUENCE_TIMEOUT', // if the connection times out\n  'ETIMEDOUT' // if the connection times out\n  ]; // Init setting values\n\n  let MYSQL, manageConns, cap, base, maxRetries, connUtilization, backoff, zombieMinTimeout, zombieMaxTimeout, maxConnsFreq, usedConnsFreq, onConnect, onConnectError, onRetry, onClose, onError, onKill, onKillError, PromiseLibrary;\n  /********************************************************************/\n\n  /**  HELPER/CONVENIENCE FUNCTIONS                                  **/\n\n  /********************************************************************/\n\n  const getCounter = () => counter;\n\n  const incCounter = () => counter++;\n\n  const resetCounter = () => counter = 0;\n\n  const getClient = () => client;\n\n  const resetClient = () => client = null;\n\n  const resetRetries = () => retries = 0;\n\n  const getErrorCount = () => errors;\n\n  const getConfig = () => _cfg;\n\n  const config = args => Object.assign(_cfg, args);\n\n  const delay = ms => new PromiseLibrary(res => setTimeout(res, ms));\n\n  const randRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n  const fullJitter = () => randRange(0, Math.min(cap, base * 2 ** retries));\n\n  const decorrelatedJitter = (sleep = 0) => Math.min(cap, randRange(base, sleep * 3));\n  /********************************************************************/\n\n  /**  CONNECTION MANAGEMENT FUNCTIONS                               **/\n\n  /********************************************************************/\n  // Public connect method, handles backoff and catches\n  // TOO MANY CONNECTIONS errors\n\n\n  const connect = async wait => {\n    try {\n      await _connect();\n    } catch (e) {\n      if (tooManyConnsErrors.includes(e.code) && retries < maxRetries) {\n        retries++;\n        wait = Number.isInteger(wait) ? wait : 0;\n        let sleep = backoff === 'decorrelated' ? decorrelatedJitter(wait) : typeof backoff === 'function' ? backoff(wait, retries) : fullJitter();\n        onRetry(e, retries, sleep, typeof backoff === 'function' ? 'custom' : backoff); // fire onRetry event\n\n        await delay(sleep).then(() => connect(sleep));\n      } else {\n        onConnectError(e); // Fire onConnectError event\n\n        throw new Error(e);\n      }\n    }\n  }; // end connect\n  // Internal connect method\n\n\n  const _connect = () => {\n    if (client === null) {\n      // if no client connection exists\n      resetCounter(); // Reset the total use counter\n      // Return a new promise\n\n      return new PromiseLibrary((resolve, reject) => {\n        // Connect to the MySQL database\n        client = MYSQL.createConnection(_cfg); // Wait until MySQL is connected and ready before moving on\n\n        client.connect(function (err) {\n          if (err) {\n            resetClient();\n            reject(err);\n          } else {\n            resetRetries();\n            onConnect(client);\n            return resolve(true);\n          }\n        }); // Add error listener (reset client on failures)\n\n        client.on('error', async err => {\n          errors++;\n          resetClient(); // reset client\n\n          resetCounter(); // reset counter\n\n          onError(err); // fire onError event (PROTOCOL_CONNECTION_LOST)\n        });\n      }); // end promise\n      // Else the client already exists\n    } else {\n      return PromiseLibrary.resolve();\n    } // end if-else\n\n  }; // end _connect\n  // Function called at the end that attempts to clean up zombies\n  // and maintain proper connection limits\n\n\n  const end = async () => {\n    if (client !== null && manageConns) {\n      incCounter(); // increment the reuse counter\n      // Check the number of max connections\n\n      let maxConns = await getMaxConnections(); // Check the number of used connections\n\n      let usedConns = await getTotalConnections(); // If over utilization threshold, try and clean up zombies\n\n      if (usedConns.total / maxConns.total > connUtilization) {\n        // Calculate the zombie timeout\n        let timeout = Math.min(Math.max(usedConns.maxAge, zombieMinTimeout), zombieMaxTimeout); // Kill zombies if they are within the timeout\n\n        let killedZombies = timeout <= usedConns.maxAge ? await killZombieConnections(timeout) : 0; // If no zombies were cleaned up, close this connection\n\n        if (killedZombies === 0) {\n          quit();\n        } // If zombies exist that are more than the max timeout, kill them\n\n      } else if (usedConns.maxAge > zombieMaxTimeout) {\n        await killZombieConnections(zombieMaxTimeout);\n      }\n    } // end if client\n\n  }; // end end() method\n  // Function that explicitly closes the MySQL connection.\n\n\n  const quit = () => {\n    if (client !== null) {\n      client.end(); // Quit the connection.\n\n      resetClient(); // reset the client to null\n\n      resetCounter(); // reset the reuse counter\n\n      onClose(); // fire onClose event\n    }\n  };\n  /********************************************************************/\n\n  /**  QUERY FUNCTIONS                                               **/\n\n  /********************************************************************/\n  // Main query function\n\n\n  const query = async function (...args) {\n    // Establish connection\n    await connect(); // Run the query\n\n    return new PromiseLibrary((resolve, reject) => {\n      if (client !== null) {\n        // If no args are passed in a transaction, ignore query\n        if (this && this.rollback && args.length === 0) {\n          return resolve([]);\n        }\n\n        client.query(...args, async (err, results) => {\n          if (err && err.code === 'PROTOCOL_SEQUENCE_TIMEOUT') {\n            client.destroy(); // destroy connection on timeout\n\n            resetClient(); // reset the client\n\n            reject(err); // reject the promise with the error\n          } else if (err && (/^PROTOCOL_ENQUEUE_AFTER_/.test(err.code) || err.code === 'PROTOCOL_CONNECTION_LOST')) {\n            resetClient(); // reset the client\n\n            return resolve(query(...args)); // attempt the query again\n          } else if (err) {\n            if (this && this.rollback) {\n              await query('ROLLBACK');\n              this.rollback(err);\n            }\n\n            reject(err);\n          }\n\n          return resolve(results);\n        });\n      }\n    });\n  }; // end query\n  // Get the max connections (either for this user or total)\n\n\n  const getMaxConnections = async () => {\n    // If cache is expired\n    if (Date.now() - _maxConns.updated > maxConnsFreq) {\n      let results = await query(`SELECT IF(@@max_user_connections > 0,\n        LEAST(@@max_user_connections,@@max_connections),\n        @@max_connections) AS total,\n        IF(@@max_user_connections > 0,true,false) AS userLimit`); // Update _maxConns\n\n      _maxConns = {\n        total: results[0].total || 0,\n        userLimit: results[0].userLimit === 1 ? true : false,\n        updated: Date.now()\n      };\n    } // end if renewing cache\n\n\n    return _maxConns;\n  }; // end getMaxConnections\n  // Get the total connections being used and the longest sleep time\n\n\n  const getTotalConnections = async () => {\n    // If cache is expired\n    if (Date.now() - _usedConns.updated > usedConnsFreq) {\n      let results = await query(`SELECT COUNT(ID) as total, MAX(time) as max_age\n        FROM information_schema.processlist\n        WHERE (user = ? AND @@max_user_connections > 0) OR true`, [_cfg.user]);\n      _usedConns = {\n        total: results[0].total || 0,\n        maxAge: results[0].max_age || 0,\n        updated: Date.now()\n      };\n    } // end if refreshing cache\n\n\n    return _usedConns;\n  }; // end getTotalConnections\n  // Kill all zombie connections that are older than the threshold\n\n\n  const killZombieConnections = async timeout => {\n    let killedZombies = 0; // Hunt for zombies (just the sleeping ones that this user owns)\n\n    let zombies = await query(`SELECT ID,time FROM information_schema.processlist\n        WHERE command = 'Sleep' AND time >= ? AND user = ?\n        ORDER BY time DESC`, [!isNaN(timeout) ? timeout : 60 * 15, _cfg.user]); // Kill zombies\n\n    for (let i = 0; i < zombies.length; i++) {\n      try {\n        await query('KILL ?', zombies[i].ID);\n        onKill(zombies[i]); // fire onKill event\n\n        killedZombies++;\n      } catch (e) {\n        // if (e.code !== 'ER_NO_SUCH_THREAD') console.log(e)\n        onKillError(e); // fire onKillError event\n      }\n    } // end for\n\n\n    return killedZombies;\n  }; // end killZombieConnections\n\n  /********************************************************************/\n\n  /**  TRANSACTION MANAGEMENT                                        **/\n\n  /********************************************************************/\n  // Init a transaction object and return methods\n\n\n  const transaction = () => {\n    let queries = []; // keep track of queries\n\n    let rollback = () => {}; // default rollback event\n\n\n    return {\n      query: function (...args) {\n        if (typeof args[0] === 'function') {\n          queries.push(args[0]);\n        } else {\n          queries.push(() => [...args]);\n        }\n\n        return this;\n      },\n      rollback: function (fn) {\n        if (typeof fn === 'function') {\n          rollback = fn;\n        }\n\n        return this;\n      },\n      commit: async function () {\n        return await commit(queries, rollback);\n      }\n    };\n  }; // Commit transaction by running queries\n\n\n  const commit = async (queries, rollback) => {\n    let results = []; // keep track of results\n    // Start a transaction\n\n    await query('START TRANSACTION'); // Loop through queries\n\n    for (let i = 0; i < queries.length; i++) {\n      // Execute the queries, pass the rollback as context\n      let result = await query.apply({\n        rollback\n      }, queries[i](results[results.length - 1], results)); // Add the result to the main results accumulator\n\n      results.push(result);\n    } // Commit our transaction\n\n\n    await query('COMMIT'); // Return the results\n\n    return results;\n  };\n  /********************************************************************/\n\n  /**  INITIALIZATION                                                **/\n\n  /********************************************************************/\n\n\n  let cfg = typeof params === 'object' && !Array.isArray(params) ? params : {};\n  MYSQL = cfg.library || require('mysql');\n  PromiseLibrary = cfg.promise || Promise; // Set defaults for connection management\n\n  manageConns = cfg.manageConns === false ? false : true; // default to true\n\n  cap = Number.isInteger(cfg.cap) ? cfg.cap : 100; // default to 100 ms\n\n  base = Number.isInteger(cfg.base) ? cfg.base : 2; // default to 2 ms\n\n  maxRetries = Number.isInteger(cfg.maxRetries) ? cfg.maxRetries : 50; // default to 50 attempts\n\n  backoff = typeof cfg.backoff === 'function' ? cfg.backoff : cfg.backoff && ['full', 'decorrelated'].includes(cfg.backoff.toLowerCase()) ? cfg.backoff.toLowerCase() : 'full'; // default to full Jitter\n\n  connUtilization = !isNaN(cfg.connUtilization) ? cfg.connUtilization : 0.8; // default to 0.7\n\n  zombieMinTimeout = Number.isInteger(cfg.zombieMinTimeout) ? cfg.zombieMinTimeout : 3; // default to 3 seconds\n\n  zombieMaxTimeout = Number.isInteger(cfg.zombieMaxTimeout) ? cfg.zombieMaxTimeout : 60 * 15; // default to 15 minutes\n\n  maxConnsFreq = Number.isInteger(cfg.maxConnsFreq) ? cfg.maxConnsFreq : 15 * 1000; // default to 15 seconds\n\n  usedConnsFreq = Number.isInteger(cfg.usedConnsFreq) ? cfg.usedConnsFreq : 0; // default to 0 ms\n  // Event handlers\n\n  onConnect = typeof cfg.onConnect === 'function' ? cfg.onConnect : () => {};\n  onConnectError = typeof cfg.onConnectError === 'function' ? cfg.onConnectError : () => {};\n  onRetry = typeof cfg.onRetry === 'function' ? cfg.onRetry : () => {};\n  onClose = typeof cfg.onClose === 'function' ? cfg.onClose : () => {};\n  onError = typeof cfg.onError === 'function' ? cfg.onError : () => {};\n  onKill = typeof cfg.onKill === 'function' ? cfg.onKill : () => {};\n  onKillError = typeof cfg.onKillError === 'function' ? cfg.onKillError : () => {};\n  let connCfg = typeof cfg.config === 'object' && !Array.isArray(cfg.config) ? cfg.config : {};\n  let escape = MYSQL.escape; // Set MySQL configs\n\n  config(connCfg); // Return public methods\n\n  return {\n    connect,\n    config,\n    query,\n    end,\n    escape,\n    quit,\n    transaction,\n    getCounter,\n    getClient,\n    getConfig,\n    getErrorCount\n  };\n}; // end exports","map":{"version":3,"sources":["/Users/isanghun/Desktop/final-web/albion-web/node_modules/serverless-mysql/index.js"],"names":["module","exports","params","client","counter","errors","retries","_cfg","_maxConns","updated","_usedConns","tooManyConnsErrors","MYSQL","manageConns","cap","base","maxRetries","connUtilization","backoff","zombieMinTimeout","zombieMaxTimeout","maxConnsFreq","usedConnsFreq","onConnect","onConnectError","onRetry","onClose","onError","onKill","onKillError","PromiseLibrary","getCounter","incCounter","resetCounter","getClient","resetClient","resetRetries","getErrorCount","getConfig","config","args","Object","assign","delay","ms","res","setTimeout","randRange","min","max","Math","floor","random","fullJitter","decorrelatedJitter","sleep","connect","wait","_connect","e","includes","code","Number","isInteger","then","Error","resolve","reject","createConnection","err","on","end","maxConns","getMaxConnections","usedConns","getTotalConnections","total","timeout","maxAge","killedZombies","killZombieConnections","quit","query","rollback","length","results","destroy","test","Date","now","userLimit","user","max_age","zombies","isNaN","i","ID","transaction","queries","push","fn","commit","result","apply","cfg","Array","isArray","library","require","promise","Promise","toLowerCase","connCfg","escape"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * This module manages MySQL connections in serverless applications.\n * More detail regarding the MySQL module can be found here:\n * https://github.com/mysqljs/mysql\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @version 1.5.3\n * @license MIT\n */\n\nmodule.exports = (params) => {\n\n  // Mutable values\n  let client = null // Init null client object\n  let counter = 0 // Total reuses counter\n  let errors = 0 // Error count\n  let retries = 0 // Retry count\n  let _cfg = {} // MySQL config globals\n\n  let _maxConns = { updated: 0 } // Cache max connections\n  let _usedConns = { updated: 0 } // Cache used connections\n\n  // Common Too Many Connections Errors\n  const tooManyConnsErrors = [\n    'ER_TOO_MANY_USER_CONNECTIONS',\n    'ER_CON_COUNT_ERROR',\n    'ER_USER_LIMIT_REACHED',\n    'ER_OUT_OF_RESOURCES',\n    'ER_CON_COUNT_ERROR',\n    'PROTOCOL_CONNECTION_LOST', // if the connection is lost\n    'PROTOCOL_SEQUENCE_TIMEOUT', // if the connection times out\n    'ETIMEDOUT' // if the connection times out\n  ]\n\n  // Init setting values\n  let MYSQL, manageConns, cap, base, maxRetries, connUtilization, backoff,\n    zombieMinTimeout, zombieMaxTimeout, maxConnsFreq, usedConnsFreq,\n    onConnect, onConnectError, onRetry, onClose, onError, onKill, onKillError, PromiseLibrary\n\n  /********************************************************************/\n  /**  HELPER/CONVENIENCE FUNCTIONS                                  **/\n  /********************************************************************/\n\n  const getCounter = () => counter\n  const incCounter = () => counter++\n  const resetCounter = () => counter = 0\n  const getClient = () => client\n  const resetClient = () => client = null\n  const resetRetries = () => retries = 0\n  const getErrorCount = () => errors\n  const getConfig = () => _cfg\n  const config = (args) => Object.assign(_cfg,args)\n  const delay = ms => new PromiseLibrary(res => setTimeout(res, ms))\n  const randRange = (min,max) => Math.floor(Math.random() * (max - min + 1)) + min\n  const fullJitter = () => randRange(0, Math.min(cap, base * 2 ** retries))\n  const decorrelatedJitter = (sleep=0) => Math.min(cap, randRange(base, sleep * 3))\n\n\n  /********************************************************************/\n  /**  CONNECTION MANAGEMENT FUNCTIONS                               **/\n  /********************************************************************/\n\n  // Public connect method, handles backoff and catches\n  // TOO MANY CONNECTIONS errors\n  const connect = async (wait) => {\n    try {\n      await _connect()\n    } catch(e) {\n      if (tooManyConnsErrors.includes(e.code) && retries < maxRetries) {\n        retries++\n        wait = Number.isInteger(wait) ? wait : 0\n        let sleep = backoff === 'decorrelated' ? decorrelatedJitter(wait) :\n          typeof backoff === 'function' ? backoff(wait,retries) :\n            fullJitter()\n        onRetry(e,retries,sleep,typeof backoff === 'function' ? 'custom' : backoff) // fire onRetry event\n        await delay(sleep).then(() => connect(sleep))\n      } else {\n        onConnectError(e) // Fire onConnectError event\n        throw new Error(e)\n      }\n    }\n  } // end connect\n\n  // Internal connect method\n  const _connect = () => {\n\n    if (client === null) { // if no client connection exists\n\n      resetCounter() // Reset the total use counter\n\n      // Return a new promise\n      return new PromiseLibrary((resolve, reject) => {\n\n        // Connect to the MySQL database\n        client = MYSQL.createConnection(_cfg)\n\n        // Wait until MySQL is connected and ready before moving on\n        client.connect(function(err) {\n          if (err) {\n            resetClient()\n            reject(err)\n          } else {\n            resetRetries()\n            onConnect(client)\n            return resolve(true)\n          }\n        })\n\n        // Add error listener (reset client on failures)\n        client.on('error', async err => {\n          errors++\n          resetClient() // reset client\n          resetCounter() // reset counter\n          onError(err) // fire onError event (PROTOCOL_CONNECTION_LOST)\n        })\n      }) // end promise\n\n    // Else the client already exists\n    } else {\n      return PromiseLibrary.resolve()\n    } // end if-else\n\n  } // end _connect\n\n\n  // Function called at the end that attempts to clean up zombies\n  // and maintain proper connection limits\n  const end = async () => {\n\n    if (client !== null && manageConns) {\n\n      incCounter() // increment the reuse counter\n\n      // Check the number of max connections\n      let maxConns = await getMaxConnections()\n\n      // Check the number of used connections\n      let usedConns = await getTotalConnections()\n\n      // If over utilization threshold, try and clean up zombies\n      if (usedConns.total/maxConns.total > connUtilization) {\n\n        // Calculate the zombie timeout\n        let timeout = Math.min(Math.max(usedConns.maxAge,zombieMinTimeout),zombieMaxTimeout)\n\n        // Kill zombies if they are within the timeout\n        let killedZombies = timeout <= usedConns.maxAge ? await killZombieConnections(timeout) : 0\n\n        // If no zombies were cleaned up, close this connection\n        if (killedZombies === 0) {\n          quit()\n        }\n\n      // If zombies exist that are more than the max timeout, kill them\n      } else if (usedConns.maxAge > zombieMaxTimeout) {\n        await killZombieConnections(zombieMaxTimeout)\n      }\n    } // end if client\n  } // end end() method\n\n\n  // Function that explicitly closes the MySQL connection.\n  const quit = () => {\n    if (client !== null) {\n      client.end() // Quit the connection.\n      resetClient() // reset the client to null\n      resetCounter() // reset the reuse counter\n      onClose() // fire onClose event\n    }\n  }\n\n\n  /********************************************************************/\n  /**  QUERY FUNCTIONS                                               **/\n  /********************************************************************/\n\n  // Main query function\n  const query = async function(...args) {\n\n    // Establish connection\n    await connect()\n\n    // Run the query\n    return new PromiseLibrary((resolve,reject) => {\n      if (client !== null) {\n        // If no args are passed in a transaction, ignore query\n        if (this && this.rollback && args.length === 0) { return resolve([]) }\n        client.query(...args, async (err, results) => {\n          if (err && err.code === 'PROTOCOL_SEQUENCE_TIMEOUT') {\n            client.destroy() // destroy connection on timeout\n            resetClient() // reset the client\n            reject(err) // reject the promise with the error\n          } else if (err && (/^PROTOCOL_ENQUEUE_AFTER_/.test(err.code) || err.code === 'PROTOCOL_CONNECTION_LOST')) {\n            resetClient() // reset the client\n            return resolve(query(...args)) // attempt the query again\n          } else if (err) {\n            if (this && this.rollback) {\n              await query('ROLLBACK')\n              this.rollback(err)\n            }\n            reject(err)\n          }\n          return resolve(results)\n        })\n      }\n    })\n\n  } // end query\n\n\n  // Get the max connections (either for this user or total)\n  const getMaxConnections = async () => {\n\n    // If cache is expired\n    if (Date.now()-_maxConns.updated > maxConnsFreq) {\n\n      let results = await query(\n        `SELECT IF(@@max_user_connections > 0,\n        LEAST(@@max_user_connections,@@max_connections),\n        @@max_connections) AS total,\n        IF(@@max_user_connections > 0,true,false) AS userLimit`\n      )\n\n      // Update _maxConns\n      _maxConns = {\n        total: results[0].total || 0,\n        userLimit: results[0].userLimit === 1 ? true : false,\n        updated: Date.now()\n      }\n\n    } // end if renewing cache\n\n    return _maxConns\n\n  } // end getMaxConnections\n\n\n  // Get the total connections being used and the longest sleep time\n  const getTotalConnections = async () => {\n\n    // If cache is expired\n    if (Date.now()-_usedConns.updated > usedConnsFreq) {\n\n      let results = await query(\n        `SELECT COUNT(ID) as total, MAX(time) as max_age\n        FROM information_schema.processlist\n        WHERE (user = ? AND @@max_user_connections > 0) OR true`,[_cfg.user])\n\n      _usedConns = {\n        total: results[0].total || 0,\n        maxAge: results[0].max_age || 0,\n        updated: Date.now()\n      }\n\n    } // end if refreshing cache\n\n    return _usedConns\n\n  } // end getTotalConnections\n\n\n  // Kill all zombie connections that are older than the threshold\n  const killZombieConnections = async (timeout) => {\n\n    let killedZombies = 0\n\n    // Hunt for zombies (just the sleeping ones that this user owns)\n    let zombies = await query(\n      `SELECT ID,time FROM information_schema.processlist\n        WHERE command = 'Sleep' AND time >= ? AND user = ?\n        ORDER BY time DESC`,\n      [!isNaN(timeout) ? timeout : 60*15, _cfg.user])\n\n    // Kill zombies\n    for (let i = 0; i < zombies.length; i++) {\n      try {\n        await query('KILL ?',zombies[i].ID)\n        onKill(zombies[i]) // fire onKill event\n        killedZombies++\n      } catch(e) {\n        // if (e.code !== 'ER_NO_SUCH_THREAD') console.log(e)\n        onKillError(e) // fire onKillError event\n      }\n    } // end for\n\n    return killedZombies\n\n  } // end killZombieConnections\n\n\n  /********************************************************************/\n  /**  TRANSACTION MANAGEMENT                                        **/\n  /********************************************************************/\n\n  // Init a transaction object and return methods\n  const transaction = () => {\n\n    let queries = [] // keep track of queries\n    let rollback = () => {} // default rollback event\n\n    return {\n      query: function(...args) {\n        if (typeof args[0] === 'function') {\n          queries.push(args[0])\n        } else {\n          queries.push(() => [...args])\n        }\n        return this\n      },\n      rollback: function(fn) {\n        if (typeof fn === 'function') { rollback = fn }\n        return this\n      },\n      commit: async function() { return await commit(queries,rollback) }\n    }\n  }\n\n  // Commit transaction by running queries\n  const commit = async (queries,rollback) => {\n\n    let results = [] // keep track of results\n\n    // Start a transaction\n    await query('START TRANSACTION')\n\n    // Loop through queries\n    for (let i = 0; i < queries.length; i++) {\n      // Execute the queries, pass the rollback as context\n      let result = await query.apply({rollback},queries[i](results[results.length-1],results))\n      // Add the result to the main results accumulator\n      results.push(result)\n    }\n\n    // Commit our transaction\n    await query('COMMIT')\n\n    // Return the results\n    return results\n  }\n\n\n  /********************************************************************/\n  /**  INITIALIZATION                                                **/\n  /********************************************************************/\n\n  let cfg = typeof params === 'object' && !Array.isArray(params) ? params : {}\n\n  MYSQL = cfg.library || require('mysql')\n  PromiseLibrary = cfg.promise || Promise\n\n  // Set defaults for connection management\n  manageConns = cfg.manageConns === false ? false : true // default to true\n  cap = Number.isInteger(cfg.cap) ? cfg.cap : 100 // default to 100 ms\n  base = Number.isInteger(cfg.base) ? cfg.base : 2 // default to 2 ms\n  maxRetries = Number.isInteger(cfg.maxRetries) ? cfg.maxRetries : 50 // default to 50 attempts\n  backoff = typeof cfg.backoff === 'function' ? cfg.backoff :\n    cfg.backoff && ['full','decorrelated'].includes(cfg.backoff.toLowerCase()) ?\n      cfg.backoff.toLowerCase() : 'full' // default to full Jitter\n  connUtilization = !isNaN(cfg.connUtilization) ? cfg.connUtilization : 0.8 // default to 0.7\n  zombieMinTimeout = Number.isInteger(cfg.zombieMinTimeout) ? cfg.zombieMinTimeout : 3 // default to 3 seconds\n  zombieMaxTimeout = Number.isInteger(cfg.zombieMaxTimeout) ? cfg.zombieMaxTimeout : 60*15 // default to 15 minutes\n  maxConnsFreq = Number.isInteger(cfg.maxConnsFreq) ? cfg.maxConnsFreq : 15*1000 // default to 15 seconds\n  usedConnsFreq = Number.isInteger(cfg.usedConnsFreq) ? cfg.usedConnsFreq : 0 // default to 0 ms\n\n  // Event handlers\n  onConnect = typeof cfg.onConnect === 'function' ? cfg.onConnect : () => {}\n  onConnectError = typeof cfg.onConnectError === 'function' ? cfg.onConnectError : () => {}\n  onRetry = typeof cfg.onRetry === 'function' ? cfg.onRetry : () => {}\n  onClose = typeof cfg.onClose === 'function' ? cfg.onClose : () => {}\n  onError = typeof cfg.onError === 'function' ? cfg.onError : () => {}\n  onKill = typeof cfg.onKill === 'function' ? cfg.onKill : () => {}\n  onKillError = typeof cfg.onKillError === 'function' ? cfg.onKillError : () => {}\n\n  let connCfg = typeof cfg.config === 'object' && !Array.isArray(cfg.config) ? cfg.config : {}\n  let escape = MYSQL.escape\n  // Set MySQL configs\n  config(connCfg)\n\n\n  // Return public methods\n  return {\n    connect,\n    config,\n    query,\n    end,\n    escape,\n    quit,\n    transaction,\n    getCounter,\n    getClient,\n    getConfig,\n    getErrorCount\n  }\n\n} // end exports\n"]},"metadata":{},"sourceType":"script"}