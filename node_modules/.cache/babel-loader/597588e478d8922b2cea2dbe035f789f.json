{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst fsAccess = promisify(fs.access);\n\nmodule.exports = createBackup => {\n  return async function backup(filename, options) {\n    if (options == null) options = {};\n    if (typeof filename !== 'string') throw new TypeError('Expected first argument to be a string');\n    if (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n    filename = filename.trim();\n    if (!filename) throw new TypeError('Backup filename cannot be an empty string');\n    if (filename === ':memory:') throw new TypeError('Invalid backup filename \":memory:\"');\n    if (filename.toLowerCase().startsWith('file:')) throw new TypeError('URI filenames are reserved for internal use only');\n    const attachedName = 'attached' in options ? options.attached : 'main';\n    const handler = 'progress' in options ? options.progress : null;\n    if (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n    if (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n    if (handler != null && typeof handler !== 'function') throw new TypeError('Expected the \"progress\" option to be a function');\n    await fsAccess(path.dirname(filename)).catch(() => {\n      throw new TypeError('Cannot save backup because the directory does not exist');\n    });\n    const newFile = await fsAccess(filename).then(() => false, () => true);\n    return runBackup(createBackup.call(this, attachedName, filename, newFile), handler || null);\n  };\n};\n\nconst runBackup = (backup, handler) => {\n  let rate = 0;\n  let useDefault = true;\n  return new Promise((resolve, reject) => {\n    setImmediate(function step() {\n      try {\n        const progress = backup.transfer(rate);\n\n        if (!progress.remainingPages) {\n          backup.close();\n          resolve(progress);\n          return;\n        }\n\n        if (useDefault) {\n          useDefault = false;\n          rate = 100;\n        }\n\n        if (handler) {\n          const ret = handler(progress);\n\n          if (ret !== undefined) {\n            if (typeof ret === 'number' && ret === ret) rate = Math.max(0, Math.min(0x7fffffff, Math.round(ret)));else throw new TypeError('Expected progress callback to return a number or undefined');\n          }\n        }\n\n        setImmediate(step);\n      } catch (err) {\n        backup.close();\n        reject(err);\n      }\n    });\n  });\n};","map":{"version":3,"sources":["/Users/isanghun/Desktop/albion-web/node_modules/better-sqlite3/lib/backup.js"],"names":["fs","require","path","promisify","fsAccess","access","module","exports","createBackup","backup","filename","options","TypeError","trim","toLowerCase","startsWith","attachedName","attached","handler","progress","dirname","catch","newFile","then","runBackup","call","rate","useDefault","Promise","resolve","reject","setImmediate","step","transfer","remainingPages","close","ret","undefined","Math","max","min","round","err"],"mappings":"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","sourcesContent":["'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\n\nconst fsAccess = promisify(fs.access);\n\nmodule.exports = (createBackup) => {\n\treturn async function backup(filename, options) {\n\t\tif (options == null) options = {};\n\t\tif (typeof filename !== 'string') throw new TypeError('Expected first argument to be a string');\n\t\tif (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n\n\t\tfilename = filename.trim();\n\t\tif (!filename) throw new TypeError('Backup filename cannot be an empty string');\n\t\tif (filename === ':memory:') throw new TypeError('Invalid backup filename \":memory:\"');\n\t\tif (filename.toLowerCase().startsWith('file:')) throw new TypeError('URI filenames are reserved for internal use only');\n\n\t\tconst attachedName = 'attached' in options ? options.attached : 'main';\n\t\tconst handler = 'progress' in options ? options.progress : null;\n\n\t\tif (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n\t\tif (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n\t\tif (handler != null && typeof handler !== 'function') throw new TypeError('Expected the \"progress\" option to be a function');\n\n\t\tawait fsAccess(path.dirname(filename)).catch(() => {\n\t\t\tthrow new TypeError('Cannot save backup because the directory does not exist');\n\t\t});\n\n\t\tconst newFile = await fsAccess(filename).then(() => false, () => true);\n\t\treturn runBackup(createBackup.call(this, attachedName, filename, newFile), handler || null);\n\t};\n};\n\nconst runBackup = (backup, handler) => {\n\tlet rate = 0;\n\tlet useDefault = true;\n\n\treturn new Promise((resolve, reject) => {\n\t\tsetImmediate(function step() {\n\t\t\ttry {\n\t\t\t\tconst progress = backup.transfer(rate);\n\t\t\t\tif (!progress.remainingPages) {\n\t\t\t\t\tbackup.close();\n\t\t\t\t\tresolve(progress);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (useDefault) {\n\t\t\t\t\tuseDefault = false;\n\t\t\t\t\trate = 100;\n\t\t\t\t}\n\t\t\t\tif (handler) {\n\t\t\t\t\tconst ret = handler(progress);\n\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\tif (typeof ret === 'number' && ret === ret) rate = Math.max(0, Math.min(0x7fffffff, Math.round(ret)));\n\t\t\t\t\t\telse throw new TypeError('Expected progress callback to return a number or undefined');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetImmediate(step);\n\t\t\t} catch (err) {\n\t\t\t\tbackup.close();\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t});\n}\n"]},"metadata":{},"sourceType":"script"}